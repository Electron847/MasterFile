#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const unsigned int millis=1000;
const unsigned int encoderDelay=millis/25; // divide 1000 by the rate in Hz
const unsigned int motorDelay=millis/10;
const unsigned int displayDelay=millis/5;
const unsigned int mainDelay=millis/50;

// robot wheel variables
const unsigned int wheelDiameter=56; // in mm

// motor power levels
const unsigned int motorForwardPower=50;
const int motorBackwardPower=-motorForwardPower;
const unsigned int motorIdlePower=0;
const unsigned int armRaisePower=10;
const int armLowerPower=-armRaisePower;
const unsigned int armEncoderTarget=100;

// distanct threshold in cm
const unsigned int distanceThreshold=500; // in mm (20 cm)

// states
enum STATES{IDLE=0,	FORWARD=1, INSPECTION=2, BACKWARD=3};
enum STATES state; // variable to hold current State

// sensor and actuator variables
int distance;
int motorPower;
bool inspectionDone;
int armMotorPower;
int armEncoderValue;

string stateNames[]={"IDLE","FORWARD","INSPECTION","BACKWARD"};

/********* TASKS *************/
task EncoderSenseTask(){
	while(1)
	{
		distance=(int)(wheelDiameter/2)*(getMotorEncoder(motorB)*PI/180);
		armEncoderValue=getMotorEncoder(motorA);
		sleep(encoderDelay);
	}
}

task MotorTask(){
	while(1)
	{
		setMotorSync(leftMotor,rightMotor,0,motorPower);
		setMotorSpeed(armMotor,armMotorPower);
		sleep(motorDelay);
	}
}

task DisplayTask(){
	while(1)
	{
		displayTextLine(1,"State = %s",stateNames[state]);
		displayTextLine(3,"Distance = %d",distance);
		displayTextLine(5,"Motor Power = %d",motorPower);
		displayTextLine(7,"Arm Power = %d",armMotorPower);
		writeDebugStreamLine("Motor %d, Arm %d, ST %d",motorPower, armMotorPower,state);
		sleep(displayDelay);
	}
}

task main()
{

	//initialize states and variables
	clearDebugStream();
	writeDebugStreamLine("Init");
	state=IDLE;
	motorPower=motorIdlePower;
	armMotorPower=motorIdlePower;
	inspectionDone=false;
	resetMotorEncoder(motorB);
	setMotorSpeed(motorA,armLowerPower);
	sleep(millis);
	resetMotorEncoder(motorA); // inspection arm motor
	armEncoderValue=getMotorEncoder(motorA);
	writeDebugStreamLine("Init done");
	bool armRaised=false;

	// start tasks
	writeDebugStreamLine("Task start");
	startTask(EncoderSenseTask);
	startTask(MotorTask);
	startTask(DisplayTask);
	writeDebugStreamLine("Task started");

	while(1)
	{
		// state transition table
		switch (state)
		{
		case IDLE:
			if(distance<distanceThreshold && inspectionDone==false)
			{
				state=FORWARD;
			}
			break;
		case FORWARD:
			if(distance>=distanceThreshold)
			{
				state=INSPECTION;
			}
			break;
		case INSPECTION:
			if (inspectionDone==true)
			{
				state=BACKWARD;
			}
			break;
		case BACKWARD:
			if (distance<=0)
			{
				state=IDLE;
			}
			break;
		default:
			state=IDLE;
			break;
		}
		// state execution table
		switch (state)
		{
		case IDLE:
			motorPower=motorIdlePower;
			break;
		case FORWARD:
			motorPower=motorForwardPower;
			break;
		case INSPECTION:
			motorPower=motorIdlePower;
			if (inspectionDone == false)
			{
				if (armEncoderValue<armEncoderTarget && armRaised==false)
				{
					armMotorPower=armRaisePower;
				}
				else
				{
					armRaised=true;
					if (armEncoderValue<=0)
					{
						armMotorPower=motorIdlePower;
						inspectionDone=true;
					}
					else
					{
						armMotorPower=armLowerPower;
					}
				}
			}
			break;
		case BACKWARD:
			motorPower=motorBackwardPower;
			break;
		default:
			motorPower=motorIdlePower;
			break;
		}
		sleep(mainDelay);
	}
}
