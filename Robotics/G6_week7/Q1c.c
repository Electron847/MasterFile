#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

float globalGyroValue = 0;
float gyroResetValue = 0;
float desiredAngle = 270;
float fulcrumPoint = (desiredAngle + gyroResetValue)/2;
const int start_motor_power = 50;
int _power = start_motor_power;
float init_motor_turn_ratio = 75;
float turnRatio = init_motor_turn_ratio;
enum STATES{IDLE=0, GO=1};
enum STATES state = IDLE;

float controller_motor_delay = 1000.0 / 25.0;
int turn_gain = 1.5;

float speed_1 = 0;
float speed_2 = 0;


task gyroSensor1()
{
	while(true)
	{
		globalGyroValue = getGyroDegrees(S2);
	}
}
task debug(){
	while(true){
		writeDebugStreamLine("current Gyro value = %d\t", globalGyroValue);
		sleep(500);
	}
}

float proportional_TurnController(){
	float error = 2*(desiredAngle - globalGyroValue);
	float out = (turn_gain * error) / (fulcrumPoint * turn_gain);
	out *= init_motor_turn_ratio;
	return out;
}

task controller_motor(){
	//int prev_power = 0;
	//int prev_ratio = 0;
	while(true){
		//if(prev_power != _power){
			setMotorSync(motorB , motorC , turnRatio , _power);
			//_power = _power - 1;
			//sleep(controller_motor_delay);
			//_power = proportional_TurnController();
		}
		sleep(controller_motor_delay);
	}


task main()
{
 clearDebugStream();
 startTask(gyroSensor1);
 startTask(debug);
 startTask(controller_motor);
 while(true)
 {
		switch(state)
        {
			case IDLE:
				if(globalGyroValue < desiredAngle) state = GO;
				break;
			case GO:
				if(globalGyroValue >= desiredAngle) state = IDLE;
				break;
		}

		switch(state)
        {
			case IDLE:
				_power =0;
				break;
			case GO:
				_power = proportional_TurnController();
				break;
		}


 }

}
