#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

float globalGyroValue = 0;
float gyroResetValue = 0;
float slewRate = 5;
float desiredAngle = 270;
float fulcrumPoint = (desiredAngle + gyroResetValue)/2;
const int start_motor_power = 120;
int _power = 0;
float init_motor_turn_ratio = 45;
float turnRatio = 75;
enum STATES{IDLE=0, GO=1, ACCEL=2};
enum STATES state = IDLE;

float controller_motor_delay = 1000.0 / 25.0;
int turn_gain = 1.5;

float speed_1 = 0;
float speed_2 = 0;


task gyroSensor1()
{
	while(true)
	{
		globalGyroValue = getGyroDegrees(S2);
	}
}
task debug(){
	while(true){
		writeDebugStreamLine("current Gyro value = %d\t Current Speed: %d", globalGyroValue, _power);
		sleep(50);
	}
}

float proportional_TurnController(){
	float error = 3*(desiredAngle - globalGyroValue);
	float out = (turn_gain * error) / (fulcrumPoint * turn_gain);
	out *= init_motor_turn_ratio;
    slewController();
	return out;
}
float slewController(){
	//float Pout =_power;
	float error = 3*(desiredAngle - globalGyroValue);
	float out = (turn_gain * error) / (fulcrumPoint * turn_gain);
	out *= init_motor_turn_ratio;
	if(_power + slewRate >= out){
			_power =	out;
		}
		else{
		_power = _power + slewRate;
	}
return _power;
}
task controller_motor(){

	while(true){

			setMotorSync(motorB , motorC , turnRatio , _power);

		}
		sleep(controller_motor_delay);
	}


task main()
{
 clearDebugStream();
 startTask(gyroSensor1);
 startTask(debug);
 startTask(controller_motor);
 while(true)
 {
		switch(state)
        {
			case IDLE:
				if(globalGyroValue < desiredAngle && globalGyroValue >= fulcrumPoint) state = GO;
				if(globalGyroValue < desiredAngle && globalGyroValue < fulcrumPoint) state = ACCEL;
				break;
			case GO:
				if(globalGyroValue >= desiredAngle) state = IDLE;
				break;
			case ACCEL:
				if(globalGyroValue >= desiredAngle) state = IDLE;
				if(globalGyroValue < desiredAngle && globalGyroValue >= fulcrumPoint) state = GO;
				break;
		}

		switch(state)
        {
			case IDLE:
				_power =0;
				break;
			case GO:
				_power = proportional_TurnController();
				break;
			case ACCEL:
				_power = slewController();
				break;
		}


	sleep(50);

 }

}
