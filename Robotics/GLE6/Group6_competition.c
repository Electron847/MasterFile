#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum STATES{IDLE=0, LEFT=1, RIGHT=2, DONE=3};
enum STATES state = IDLE;
//Light
int init_startD = 90;
//Dark
int init_startC = 0 ;
//minimum threshold
float colorMin = (init_startC + init_startD) / 2;
float globalGyroValue = 0;
double this_color = -1;
int colorSenseDelay = 200 / 1000;
const float start_motor_power = 45;
int _power = start_motor_power;
const double beginningTurn_ratio = 75;
double turnRatio = beginningTurn_ratio;
int controller_motor_delay = 500 / 1000;
int turn_gain = 1.5;
int debug_sleep = 1000 / 5;
int color;


task senseColor()
{
	while(true)
    {
		this_color = getColorReflected(S3);
		color = getColorName(S3);
		sleep(colorSenseDelay);
	}
}

task motorControl()
{
	int prev_power = 0;
	int prev_ratio = 0;
	while(true)
    {
		if(prev_power != _power || prev_ratio != turnRatio){
			setMotorSync(motorB , motorC , turnRatio , _power);
		}
		prev_power = _power;
		prev_ratio = turnRatio;
		sleep(controller_motor_delay);
	}
}

task debug(){
	while(true){
		writeDebugStreamLine("current_color=%d\n\t motor_power=%d\n\t\t motor_turn_ratio=%d\n\t\t state=%d gyro: %d" , this_color, _power, turnRatio, state, globalGyroValue);
		sleep(debug_sleep);
	}
}
task gyroSensor1()
{
	while(true)
	{
		globalGyroValue = getGyroDegrees(S2);
	}
}

double proportionRatio(){
	double discrepancy = this_color - colorMin;
	double out = (turn_gain * discrepancy) / (colorMin * turn_gain);
	out *= -1 * beginningTurn_ratio;
	return out;
}

task main()
{
	setMotorSync(motorB , motorC , 0 , 75);
	//sleep(400);
	//setMotorSync(motorB , motorC , -15 , 15);
	//sleep(100);
	moveMotorTarget(motorA, -70, 80);
	sleep(1100);
	//moveMotorTarget(motorA, 40, 50);
	//sleep(2000);
	clearDebugStream();
	startTask(senseColor);
	startTask(motorControl);
	startTask(debug);
	startTask(gyroSensor1);

//	sleep(256);

	while(true)
    {

		switch(state)
        {
			case IDLE:
				if(this_color != colorMin) state = LEFT;
				//if(this_color <= colorMin) state = RIGHT;
				if(color==colorRed && globalGyroValue>=350) state = DONE;
				break;
			case LEFT:
				if(this_color <= colorMin) state = RIGHT;
				if(color==colorRed && globalGyroValue>=350) state = DONE;
				break;
			case RIGHT:
				if(this_color > colorMin) state = LEFT;
				if(color==colorRed && globalGyroValue>=350) state = DONE;
				break;
			case DONE:
				break;
		}

		switch(state)
        {
			case IDLE:
			moveMotorTarget(motorA, -70, 80);
			sleep(2000);
			_power=0;
				break;
			case LEFT:
				turnRatio = proportionRatio();
				break;
			case RIGHT:
				turnRatio = proportionRatio();
				break;
			case DONE:
				_power=0;
					moveMotorTarget(motorA, 70, 80);
					sleep(2000);
				break;
		}
	}
}
